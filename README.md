 # **<div align="center">DAA PRACTICAL FILE</div>**

```
```

<table align="center">
<thead>
<tr>
  <th>S.no.</th>
  <th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1.</td>
  <td><a href="https://github.com/shivanshkumar999/DAA-Practical-File/blob/main/Insertion%20Sort(1.a).cpp">Red Black Tree</a></td>
</tr>
<tr>
  <td>2.</td>
  <td><a href="https://github.com/shivanshkumar999/DAA-Practical-File/blob/main/Minimum%20Spanning%20Tree%20(9%20que).cpp">Minimum Spanning Tree</td>
</tr>  
<tr>
  <td>3.</td>
  <td><a href="https://github.com/shivanshkumar999/DAA-Practical-File/blob/main/Comparisons%20of%20different%20sorts.cpp">Implementing Different Sorts</td>
</tr>
</tbody>
</table>

```
```

<br>

- ## Analysis for Red Black Tree

```
A red–black tree is a kind of self-balancing binary search tree in computer science.
Each node of the binary tree has an extra bit, and that bit is often interpreted as the color (red or black) of the node. 
These color bits are used to ensure the tree remains approximately balanced during insertions and deletions.
```
<br>

> ### Insertion Happens in this way
<br>
<img src="https://iq.opengenus.org/content/images/2018/07/red-black-tree_-insertion.jpg" align="left">
 
 <br>
 
>- #### Complexity for **INSERTION**
  <br>
  Average and Worst case insertion time complexity: **Θ(log n)**

  Average and Worst case Space complexity: **Θ(n)**

<br>

> ### Deletion Happens in this way
<br>
<img src="https://iq.opengenus.org/content/images/2018/07/red-black-tree_-deletion.jpg" >

<br>

>- #### Complexity for **DELETION**
  <br>
  Average and Worst case deletion time complexity: **Θ(log n)**

  Average and Worst case Space complexity: **Θ(n)**

<br>

> ### Search Happens in this way
> <br>
<img src ="https://iq.opengenus.org/content/images/2018/07/rb-tree-search-1.jpg">

>- #### Complexity for **SEARCHING**
<br>
  Average and Worst case deletion time complexity: **Θ(log n)**

  Average and Worst case Space complexity: **Θ(n)**
  
  ```
  ```
  <br>
  
  - ## Analysis for Minimum Spanning Tree
  
  
  ```
  The cost of the spanning tree is the sum of the weights of all the edges in the tree. 
  There can be many spanning trees. 
  Minimum spanning tree is the spanning tree where the cost is minimum among all the spanning trees. 
  There also can be many minimum spanning trees.
  Here PRIM'S greedy algorithm is used.
  ```
  
  <br>
  
 > ### Prim's Algo Working
 <br>
<img src="https://aquarchitect.github.io/swift-algorithm-club/Minimum%20Spanning%20Tree/Images/prim.png">
 <br>
 
 
>- #### Complexity for **PRIM'S ALGORITHM**

The time complexity of the Prim’s Algorithm is **O((V + E)logV)** because each vertex is inserted in the priority queue only once and insertion in priority queue take logarithmic time.

 ```
 ```
 <br>
  
  - ## Analysis for Different Sorts
```

